Design a new paradigm of programming that uses a context as a first argument passed to all functions (along with but preceding other arguments). This explicit context is how the environment is injected into the functions and contains all dependencies of the functions (as a typed collection). All mutable state, similarly, is contained in the context so all side effects are modelled as changes to the context passed in. This allows for synchronisation and checkpointing of concurrent executions. This new paradigm combines functional and procedural programming with object oriented programming.

The context is typed but extensively uses type inference to ensure that the context contains all the typed dependencies the functions require. Any type can only appear once in a context. So lower cased type names can be used to dereference the context’s state variables uniquely. A context could be a single object (class instance) or derived objects (subtypes) or a module or namespace or combinations of these built up by combining module scopes. Additional function arguments can be “by value” and “by reference” but immutability is encouraged and could be type checked for. Results are passed back by a function as one value or a tuple (of 2 or more values - but not including the context). Functions can be overloaded by context type with a runtime dispatch choosing the function to call (one of an overloaded set) based on the context type.

Testing makes use of a mock version of the context, invariants on the context, as well as before and after assertions. Runtime safety check similarly can test the context passed using assertions. Context are policed with assertions and invariants while functional code could mostly be proof checked. Errors are passed back explicitly (in result tuples) but not in the context. The context may contain partial results on errors or be in an invalid state that requires recovery but this is discouraged - updating context only at safe points in the function is strongly encouraged. One way to represent this processing style in diagrams is with inputs on left and results on the right, with context coming from above and being passed down below for the next level of transformation, resulting in a (diagonal) lattice style diagramming of computation.

The resulting paradigm is called context oriented or context aware programming. No context or an empty context would be used for pure functional programming, while a single “self” object as context is a form of (explicit) extensible object oriented programming. Concurrent programming is done by spawning a new thread on a context and invoking a function. Contexts can also be serialised (check-pointed). This allows migration of computation and persistence (later de-serialisation) of state and computation. In Javascript or Python all context aware functions must be async and return a Promise so that external computation can be overlapped and awaited.

A context could include a DB client, a queue or queues for work input and piped output, LLM or other AI models, managing dependencies in the form of context aware API. The aim is to allow AI code generation to generate clean code that can be more easily understood by humans or other AI that consume context aware APIs. The specification given to the AI is divided between a description of the environment and the dependencies (the context) and the inputs and outputs, which are handled as functional arguments. When communicating with a AI model, the context becomes what is passed into the model, wholly or as a sub-set of the current context. This allows hand-over and collaboration between AI models or Agent APIs. Safety is made simpler by checking the context upon update for unwanted side effects. 

Write a programming manual for a context oriented programming language called Cop-on. Use taste to make syntax express the above semantics of contexts but don’t engage in language wars. Make it applicable to AI workflows. Changes can be proposed if there are inconsistencies or unintended feature interactions as the design is fleshed out.

